{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = exports.isMultipartBody = exports.toFile = exports.isUploadable = exports.isBlobLike = exports.isFileLike = exports.isResponseLike = exports.fileFromPath = void 0;\nconst index_1 = require(\"./_shims/index.js\");\nvar index_2 = require(\"./_shims/index.js\");\nObject.defineProperty(exports, \"fileFromPath\", {\n  enumerable: true,\n  get: function () {\n    return index_2.fileFromPath;\n  }\n});\nconst isResponseLike = value => value != null && typeof value === 'object' && typeof value.url === 'string' && typeof value.blob === 'function';\nexports.isResponseLike = isResponseLike;\nconst isFileLike = value => value != null && typeof value === 'object' && typeof value.name === 'string' && typeof value.lastModified === 'number' && (0, exports.isBlobLike)(value);\nexports.isFileLike = isFileLike;\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = value => value != null && typeof value === 'object' && typeof value.size === 'number' && typeof value.type === 'string' && typeof value.text === 'function' && typeof value.slice === 'function' && typeof value.arrayBuffer === 'function';\nexports.isBlobLike = isBlobLike;\nconst isUploadable = value => {\n  return (0, exports.isFileLike)(value) || (0, exports.isResponseLike)(value) || (0, index_1.isFsReadStream)(value);\n};\nexports.isUploadable = isUploadable;\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nasync function toFile(value, name, options = {}) {\n  // If it's a promise, resolve it.\n  value = await value;\n  if ((0, exports.isResponseLike)(value)) {\n    const blob = await value.blob();\n    name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file');\n    return new index_1.File([blob], name, options);\n  }\n  const bits = await getBytes(value);\n  name || (name = getName(value) ?? 'unknown_file');\n  if (!options.type) {\n    const type = bits[0]?.type;\n    if (typeof type === 'string') {\n      options = {\n        ...options,\n        type\n      };\n    }\n  }\n  return new index_1.File(bits, name, options);\n}\nexports.toFile = toFile;\nasync function getBytes(value) {\n  let parts = [];\n  if (typeof value === 'string' || ArrayBuffer.isView(value) ||\n  // includes Uint8Array, Buffer, etc.\n  value instanceof ArrayBuffer) {\n    parts.push(value);\n  } else if ((0, exports.isBlobLike)(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(chunk); // TODO, consider validating?\n    }\n  } else {\n    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);\n  }\n  return parts;\n}\nfunction propsForError(value) {\n  const props = Object.getOwnPropertyNames(value);\n  return `[${props.map(p => `\"${p}\"`).join(', ')}]`;\n}\nfunction getName(value) {\n  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) ||\n  // For fs.ReadStream\n  getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop();\n}\nconst getStringFromMaybeBuffer = x => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\nconst isAsyncIterableIterator = value => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\nconst isMultipartBody = body => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\nexports.isMultipartBody = isMultipartBody;\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nconst maybeMultipartFormRequestOptions = async opts => {\n  if (!hasUploadableValue(opts.body)) return opts;\n  const form = await (0, exports.createForm)(opts.body);\n  return (0, index_1.getMultipartRequestOptions)(form, opts);\n};\nexports.maybeMultipartFormRequestOptions = maybeMultipartFormRequestOptions;\nconst multipartFormRequestOptions = async opts => {\n  const form = await (0, exports.createForm)(opts.body);\n  return (0, index_1.getMultipartRequestOptions)(form, opts);\n};\nexports.multipartFormRequestOptions = multipartFormRequestOptions;\nconst createForm = async body => {\n  const form = new index_1.FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\nexports.createForm = createForm;\nconst hasUploadableValue = value => {\n  if ((0, exports.isUploadable)(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue(value[k])) return true;\n    }\n  }\n  return false;\n};\nconst addFormValue = async (form, key, value) => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n  }\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if ((0, exports.isUploadable)(value)) {\n    const file = await toFile(value);\n    form.append(key, file);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map(entry => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n  } else {\n    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n  }\n};","map":{"version":3,"names":["index_1","require","index_2","Object","defineProperty","exports","enumerable","get","fileFromPath","isResponseLike","value","url","blob","isFileLike","name","lastModified","isBlobLike","size","type","text","slice","arrayBuffer","isUploadable","isFsReadStream","toFile","options","URL","pathname","split","pop","File","bits","getBytes","getName","parts","ArrayBuffer","isView","push","isAsyncIterableIterator","chunk","Error","constructor","propsForError","props","getOwnPropertyNames","map","p","join","getStringFromMaybeBuffer","filename","path","x","Buffer","String","undefined","Symbol","asyncIterator","isMultipartBody","body","toStringTag","maybeMultipartFormRequestOptions","opts","hasUploadableValue","form","createForm","getMultipartRequestOptions","multipartFormRequestOptions","FormData","Promise","all","entries","key","addFormValue","Array","isArray","some","k","TypeError","append","file","entry","prop"],"sources":["/Users/wh1skyne/WebstormProjects/ChatAI/Backend/node_modules/openai/src/uploads.ts"],"sourcesContent":["import { type RequestOptions } from './core';\nimport {\n  FormData,\n  File,\n  type Blob,\n  type FilePropertyBag,\n  getMultipartRequestOptions,\n  type FsReadStream,\n  isFsReadStream,\n} from './_shims/index';\nimport { MultipartBody } from './_shims/MultipartBody';\nexport { fileFromPath } from './_shims/index';\n\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\n\n/**\n * Typically, this is a native \"File\" class.\n *\n * We provide the {@link toFile} utility to convert a variety of objects\n * into the File class.\n *\n * For convenience, you can also pass a fetch Response, or in Node,\n * the result of fs.createReadStream().\n */\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\n\n/**\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\n */\nexport interface BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\n  readonly size: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\n  readonly type: string;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\n  text(): Promise<string>;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\n  slice(start?: number, end?: number): BlobLike;\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\n}\n\n/**\n * Intended to match web.File, node.File, node-fetch.File, etc.\n */\nexport interface FileLike extends BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\n  readonly lastModified: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\n  readonly name: string;\n}\n\n/**\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\n */\nexport interface ResponseLike {\n  url: string;\n  blob(): Promise<BlobLike>;\n}\n\nexport const isResponseLike = (value: any): value is ResponseLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.url === 'string' &&\n  typeof value.blob === 'function';\n\nexport const isFileLike = (value: any): value is FileLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.name === 'string' &&\n  typeof value.lastModified === 'number' &&\n  isBlobLike(value);\n\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.size === 'number' &&\n  typeof value.type === 'string' &&\n  typeof value.text === 'function' &&\n  typeof value.slice === 'function' &&\n  typeof value.arrayBuffer === 'function';\n\nexport const isUploadable = (value: any): value is Uploadable => {\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\n\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(\n  value: ToFileInput | PromiseLike<ToFileInput>,\n  name?: string | null | undefined,\n  options: FilePropertyBag | undefined = {},\n): Promise<FileLike> {\n  // If it's a promise, resolve it.\n  value = await value;\n\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\n\n    return new File([blob as any], name, options);\n  }\n\n  const bits = await getBytes(value);\n\n  name ||= getName(value) ?? 'unknown_file';\n\n  if (!options.type) {\n    const type = (bits[0] as any)?.type;\n    if (typeof type === 'string') {\n      options = { ...options, type };\n    }\n  }\n\n  return new File(bits, name, options);\n}\n\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\n  let parts: Array<BlobPart> = [];\n  if (\n    typeof value === 'string' ||\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n    value instanceof ArrayBuffer\n  ) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(chunk as BlobPart); // TODO, consider validating?\n    }\n  } else {\n    throw new Error(\n      `Unexpected data type: ${typeof value}; constructor: ${\n        value?.constructor?.name\n      }; props: ${propsForError(value)}`,\n    );\n  }\n\n  return parts;\n}\n\nfunction propsForError(value: any): string {\n  const props = Object.getOwnPropertyNames(value);\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n\nfunction getName(value: any): string | undefined {\n  return (\n    getStringFromMaybeBuffer(value.name) ||\n    getStringFromMaybeBuffer(value.filename) ||\n    // For fs.ReadStream\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\n  );\n}\n\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\n\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n\nexport const isMultipartBody = (body: any): body is MultipartBody =>\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async <T extends {} = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  if (!hasUploadableValue(opts.body)) return opts;\n\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const multipartFormRequestOptions = async <T extends {} = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\n\nconst hasUploadableValue = (value: unknown): boolean => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue((value as any)[k])) return true;\n    }\n  }\n  return false;\n};\n\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\n    );\n  }\n\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (isUploadable(value)) {\n    const file = await toFile(value);\n    form.append(key, file as File);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\n    );\n  } else {\n    throw new TypeError(\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\n    );\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}